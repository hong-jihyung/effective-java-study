# clone 재정의는 주의해서 진행해라

### Cloneable 문제가 있다
- 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스
- 정작 clone 메서드는 Object 에 protected 로 있음
- 하지만 여러 문제에도 불구하고 Cloneable 방식은 널리 쓰이고 있으니 잘 탐구해보자

### interface Cloneable
- 해당 구현 클래스에서 clone 을 호출하면, 객체의 필드를 하나하나 복사한 객체를 반환함.
- Cloneable 이 아닌 클래스에서 clone 호출하면, CloneNotSupportedException
- cloneable 인터페이스의 유무는 상위 클래스에 정의된 protected 메서드의 동작 방식을 결정한다.

### clone
- 생성자를 호출하지 않고도 객체를 생성할 수 있게 된다.
- clone 메서드의 허술한 일반 규약 p78
- 생성자 연쇄와 살짝 비슷
- 쓸데없는 복사를 지양한다는 관점에서 보면 불변 클래스는 굳이 clone 메서드를 제공하지 않는게 좋다. 13-1
  + 공변 반환 타이핑 (covariant return typing)
  + 재정의한 메서드의 반환 타입은(PhoneNumber), 상위 클래스의 메서드가 반환하는 타입의(Object) 하위 타입일 수 있다.
  + 클라이언트가 형변환을 할 수고를 덜어준다.

### stack 예제 p80
- 기본형은 clone 으로 잘 복제
- 참조는 원본 인스턴스와 같은 참조를 보게 됨
- clone 은 원본 객체에 영향을 주지 않으면서, 복제된 객체의 불변식을 보장해야 함.
- elements 배열의 clone을 재귀적으로 호출하자. 13-2
  + 배열의 clone 은 런타임 타입과 컴파일 타입 모두가 원본 배열과 같은 배열을 반환함.
  + 배열을 복제할 때는 배열의 clone 메서드 사용을 권장함.
  + 배열이 clone 기능을 제대로 사용하는 유일한 예!!
  + 복제할 수 있는 클래스를 만들기 위해 일부 필드에서 final 을 제거해야 할 수도 있다.
- 배열 안에서도 같은 linkedlist 를 참조하네? 13-3
  + linkedlist 이것도 각각 복사하자. 13-4
  + deepCopy
  + 재귀적으로 돌지 말고, 반복자를 써서 순회하는 방향으로 수정 13-5

### 복잡한 가변 객체를 복제하는 마지막 방법
- super.clone 으로 객체의 모든 필드 초기화
- 원본 객체의 상태를 다시 생성하는 고수준 메서드를 호출. p84
- 코드는 깔끔해지지만, 저수준에서 처리할 때보단 느리다.
- cloneable 아키텍처의 기초가 되는 필드 단위 객체 복사를 우회하기 때문에, 전체 Cloneable 아키텍처와는 어울리지 않는 방식.
- 하위 클래스에서 재정의한 메서드가 clone 에서 호출되지 않도록 clone 내에서 사용할 메서드는 final 이거나 private 이어야 함.

- 상속용 클래스는 Cloneable 구현하지 마라
- 하위 클래스에서 cloneable 못 쓰게 하는 예제 13-6

### cloneable 구현 요약
- cloneable 을 구현하는 모든 클래스는 clone 을 재정의 해야 함.
- 이때 접근 제한자는 public, 반환 타입은 클래스 자신으로 변경. 13-1
- super.clone 먼저 호출
- 참조 구석구석 deep copy
  + clone 을 재귀적으로 호출해 구현하거나, 알아서 잘 하거나. ex. 13-5
- 일련번호나 고유ID 는 기본 타입이나 불변이어도 수정해야 한다.

### 복사 생성자, 복사 팩터리
- 13-7 public Yum(Yum yum)
- 언어 모순적이고 위험천만한 객체 생성 매커니즘을(생성자를 쓰지 않는 방식) 사용하지 않고, 엉성하게 문서화된 규약에 기대지 않고, 정상적인 final 필드 용법과도 충돌하지 않으며, 불필요한 검사 예외를 던지지도 않고, 형변환도 필요치 않다.
- 변환 생성자, 변환 팩터리
- 예. hashset 객체 s 를 treeset 타입으로 복제할 수 있음.
  + ex. new TreeSet<>(s)
  + clone 으로는 불가능하다.

### 핵심 정리
- cloneable 은 문제가 많다.
- 새로운 인터페이스를 만들 때 절대 cloneable 을 확장해선 안되고, 새로운 클래스도 이를 구현해선 안된다.
- 성능 최적화 관점에서 별 다른 문제가 없을 때만 드물게 허용해야 한다!!
- 기본 원칙은 "복제 기능은 생성자와 팩터리를 이용하는게 최고"
- 예외적으로, 배열은 clone 메서드 방식이 가장 깔끔하다.
